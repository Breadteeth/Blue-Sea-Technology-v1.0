This file is a merged representation of the entire codebase, combined into a single document.
Generated by Repomix on: 2025-03-21T13:12:58.572Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
api.py
bidding.py
blockchain.py
demand.py
main.py
payment.py
README.md
requirements.txt
testnet.py
tokens.py
visuals.py

================================================================
Files
================================================================

================
File: api.py
================
import random
from typing import Dict, Any, Optional
import time
from datetime import datetime, timedelta
import math
from blockchain import blockchain

# 模拟全局物流状态存储，用于在模拟环境中存储和更新物流状态
# 必要性：在模拟环境中，我们没有真实的物流系统数据库，因此使用全局字典来模拟状态存储
# 合理性：这种方法简化了状态管理，适合快速验证支付和物流流程，而无需引入复杂的数据库或外部 API
global_logistics_status = {}

# 全局 PaymentSystem 实例，由 main.py 设置
# 必要性：api.py 需要访问 PaymentSystem 实例以获取支付状态，确保物流状态与支付状态一致
# 合理性：在模拟环境中，通过全局变量共享实例是一种简化实现的方式，避免了复杂的依赖注入
global_payment_system = None

class LogisticsAPI:
    def __init__(self):
        self.carbon_factors = {
            "sea": (0.01, 0.02),
            "land": (0.05, 0.08),
            "air": (0.45, 0.55)
        }
        self.distances = {
            ("Shanghai", "Singapore"): 4480,
            ("Shanghai", "Bangkok"): 3780,
            ("Singapore", "Jakarta"): 880,
            ("Bangkok", "Ho Chi Minh"): 750
        }
        self.exchange_rates = {
            "USD": {"CNY": 6.45, "EUR": 0.85, "SGD": 1.35},
            "CNY": {"USD": 0.155, "EUR": 0.13, "SGD": 0.21},
            "EUR": {"USD": 1.18, "CNY": 7.65, "SGD": 1.59}
        }
        self.weather_conditions = ["clear", "rain", "storm", "fog"]
    
    def calculate_distance(self, origin: str, destination: str) -> float:
        direct = (origin, destination)
        reverse = (destination, origin)
        if direct in self.distances:
            return self.distances[direct]
        elif reverse in self.distances:
            return self.distances[reverse]
        else:
            # 模拟多段运输
            midpoints = ["Singapore", "Bangkok"]
            if random.random() > 0.5 and origin not in midpoints and destination not in midpoints:
                midpoint = random.choice(midpoints)
                return self.calculate_distance(origin, midpoint) + self.calculate_distance(midpoint, destination)
            return random.uniform(500, 5000)
    
    def fetch_carbon_footprint(self, distance: float, transport_type: str, weight: float = 1.0) -> float:
        if transport_type not in self.carbon_factors:
            raise ValueError(f"Unknown transport type: {transport_type}")
        min_factor, max_factor = self.carbon_factors[transport_type]
        factor = random.uniform(min_factor, max_factor)
        # 考虑天气影响
        weather = random.choice(self.weather_conditions)
        weather_factor = 1.0 if weather == "clear" else 1.2 if weather == "rain" else 1.5
        return distance * weight * factor * weather_factor
    
    def check_logistics_status(self, tracking_number: str) -> Dict[str, Any]:
        # 从全局 PaymentSystem 实例中获取当前阶段，确保物流状态与支付状态一致
        # 必要性：支付系统依赖物流状态来验证支付条件（如 advance_payment 中的检查）
        # 合理性：在模拟环境中，通过全局实例共享状态是一种简化实现的方式，避免了复杂的实例管理和状态同步机制
        global global_payment_system
        if global_payment_system is None:
            print("Debug: global_payment_system is None, falling back to default stage")
            current_stage = "warehouse"
        else:
            payment = global_payment_system.payments.get(tracking_number, {})
            current_stage = payment.get("current_stage", "warehouse")
            print(f"Debug: Retrieved current_stage from payment system: {current_stage}")

        # 如果 global_logistics_status 中有记录，更新 current_stage
        if tracking_number in global_logistics_status:
            global_logistics_status[tracking_number]["current_stage"] = current_stage
        else:
            # 初始化物流状态
            global_logistics_status[tracking_number] = {
                "tracking_number": tracking_number,
                "current_stage": current_stage,
                "status": "normal",
                "last_update": datetime.now().isoformat(),
                "location": "Shanghai",
                "estimated_arrival": (datetime.now() + timedelta(days=2)).isoformat(),
                "delay_hours": 0
            }

        return global_logistics_status[tracking_number]
    
    def update_logistics_status(self, tracking_number: str, stage: str) -> None:
        # 更新物流状态
        # 必要性：支付系统在推进阶段后需要通知物流系统更新状态，以保持两者一致
        # 合理性：在模拟环境中，使用全局字典模拟状态更新，简化了真实物流系统的复杂性
        print(f"Debug: Updating logistics status for tracking_number: {tracking_number} to stage: {stage}")
        if tracking_number in global_logistics_status:
            global_logistics_status[tracking_number]["current_stage"] = stage
            global_logistics_status[tracking_number]["last_update"] = datetime.now().isoformat()
            global_logistics_status[tracking_number]["location"] = "Singapore" if stage == "transport" else "Shanghai"
        else:
            global_logistics_status[tracking_number] = {
                "tracking_number": tracking_number,
                "current_stage": stage,
                "status": "normal",
                "last_update": datetime.now().isoformat(),
                "location": "Shanghai",
                "estimated_arrival": (datetime.now() + timedelta(days=2)).isoformat(),
                "delay_hours": 0
            }
    
    def verify_compliance(self, user_id: str, amount: float, transaction_type: str) -> bool:
        # 简化合规性检查，始终返回 True
        # 必要性：在模拟环境中，合规性检查不是核心功能，简化后可以专注于支付和物流流程
        # 合理性：在真实系统中，合规性检查可能涉及复杂的规则（如 KYC、AML 检查），但在模拟程序中可以忽略
        credit_score = blockchain.get_node_credit_score(user_id)
        print(f"Debug: {user_id} credit_score = {credit_score}")
        return True
    
    def get_exchange_rate(self, from_currency: str, to_currency: str) -> Optional[float]:
        if from_currency not in self.exchange_rates or to_currency not in self.exchange_rates[from_currency]:
            return None
        base_rate = self.exchange_rates[from_currency][to_currency]
        # 动态波动基于时间
        hour = datetime.now().hour
        fluctuation = math.sin(hour / 24 * 2 * math.pi) * 0.05  # ±5%日内波动
        return base_rate * (1 + fluctuation)

logistics_api = LogisticsAPI()

def calculate_distance(*args, **kwargs):
    return logistics_api.calculate_distance(*args, **kwargs)

def fetch_carbon_footprint(*args, **kwargs):
    return logistics_api.fetch_carbon_footprint(*args, **kwargs)

def check_logistics_status(*args, **kwargs):
    return logistics_api.check_logistics_status(*args, **kwargs)

def verify_compliance(*args, **kwargs):
    return logistics_api.verify_compliance(*args, **kwargs)

def get_exchange_rate(*args, **kwargs):
    return logistics_api.get_exchange_rate(*args, **kwargs)

def update_logistics_status(*args, **kwargs):
    return logistics_api.update_logistics_status(*args, **kwargs)

================
File: bidding.py
================
from typing import List, Dict, Any, Optional, Tuple
import random
import time
from datetime import datetime, timedelta
from api import calculate_distance, fetch_carbon_footprint, verify_compliance
from dataclasses import dataclass
import math
from blockchain import blockchain

@dataclass
class BidConfig:
    min_bidders: int = 1 #降低要求
    first_round_time: int = 3600 * 24  #延长到24小时
    second_round_time: int = 1800
    max_price_increase: float = 0.2
    min_carbon_compensation: int = 50

@dataclass
class TransportRoute:
    origin: str
    destination: str
    transport_type: str
    distance: float
    carrier: str
    estimated_time: int
    carbon_footprint: float
    base_price: float

    def to_dict(self):
        """将 TransportRoute 转换为可序列化的字典"""
        return {
            "origin": self.origin,
            "destination": self.destination,
            "transport_type": self.transport_type,
            "distance": self.distance,
            "carrier": self.carrier,
            "estimated_time": self.estimated_time,
            "carbon_footprint": self.carbon_footprint,
            "base_price": self.base_price
        }

class BiddingSystem:
    def __init__(self):
        self.bids: Dict[str, Dict] = {}
        self.config = BidConfig()
        self.transport_types = {
            "sea": {"speed": 30, "base_rate": 0.5},
            "land": {"speed": 60, "base_rate": 0.8},
            "air": {"speed": 800, "base_rate": 4.0}
        }
    
    def start_bidding(self, demand: Dict[str, Any]) -> str:
        bid_id = self._generate_bid_id(demand)
        self.bids[bid_id] = {
            "id": bid_id,
            "demand": demand,
            "status": "first_round",
            "start_time": time.time(),
            "first_round_bids": [],
            "second_round_bids": [],
            "solutions": None,
            "selected_solution": None
        }
        blockchain.add_transaction({"type": "bidding_started", "bid_id": bid_id, "demand": demand})
        return bid_id
    
    def submit_first_round_bid(self, bid_id: str, carrier_id: str, 
                          base_price: float, transport_type: str) -> bool:
        if bid_id not in self.bids or self.bids[bid_id]["status"] != "first_round":
            return False
        if time.time() - self.bids[bid_id]["start_time"] > self.config.first_round_time:
            return False
        
        # 身份验证
        if not verify_compliance(carrier_id, base_price, "bidding_participation"):
            return False
        
        bid = self.bids[bid_id]
        route = self._calculate_route(bid["demand"], transport_type, carrier_id)
        bid_entry = {
            "carrier_id": carrier_id,
            "base_price": base_price,
            "transport_type": transport_type,
            "route": route.to_dict(),  # 转换为字典
            "timestamp": datetime.now().isoformat()
        }
        bid["first_round_bids"].append(bid_entry)
        bid["first_round_count"] = len(bid["first_round_bids"])
        blockchain.add_transaction({"type": "first_round_bid", "bid_id": bid_id, "data": bid_entry})
        return True
    
    def start_second_round(self, bid_id: str) -> bool:
        if bid_id not in self.bids or len(self.bids[bid_id]["first_round_bids"]) < self.config.min_bidders:
            return False
        
        bid = self.bids[bid_id]
        bid["status"] = "second_round"
        bid["second_round_bids"] = []
        bid["second_round_count"] = 0
        bid["second_round_start_time"] = time.time()  # 确保设置时间
        return True
    
    def submit_second_round_bid(self, bid_id: str, carrier_id: str, 
                           final_price: float, carbon_compensation: int) -> bool:
        if bid_id not in self.bids or self.bids[bid_id]["status"] != "second_round":
            return False
        
        # 确保 second_round_start_time 存在
        if "second_round_start_time" not in self.bids[bid_id]:
            self.bids[bid_id]["second_round_start_time"] = time.time()
        
        if time.time() - self.bids[bid_id]["second_round_start_time"] > self.config.second_round_time:
            return False
        
        # 身份验证
        if not verify_compliance(carrier_id, final_price, "bidding_participation"):
            return False
        
        # 验证价格和碳补偿
        first_bids = self.bids[bid_id]["first_round_bids"]
        first_bid = next((b for b in first_bids if b["carrier_id"] == carrier_id), None)
        if not first_bid:
            return False
        if final_price > first_bid["base_price"] * (1 + self.config.max_price_increase):
            return False
        if carbon_compensation < self.config.min_carbon_compensation:
            return False
        
        bid = self.bids[bid_id]
        bid_entry = {
            "carrier_id": carrier_id,
            "final_price": final_price,
            "carbon_compensation": carbon_compensation,
            "timestamp": datetime.now().isoformat()
        }
        bid["second_round_bids"].append(bid_entry)
        bid["second_round_count"] = len(bid["second_round_bids"])
        blockchain.add_transaction({"type": "second_round_bid", "bid_id": bid_id, "data": bid_entry})
        return True
    
    def generate_solutions(self, bid_id: str) -> List[Dict[str, Any]]:
        if bid_id not in self.bids or self.bids[bid_id]["status"] != "second_round":
            return []
        
        bid = self.bids[bid_id]
        solutions = []
        for second_bid in bid["second_round_bids"]:
            first_bid = next(b for b in bid["first_round_bids"] if b["carrier_id"] == second_bid["carrier_id"])
            route = first_bid["route"]
            solution = {
                "carrier_id": second_bid["carrier_id"],
                "transport_type": first_bid["transport_type"],
                "price": second_bid["final_price"],
                "carbon_compensation": second_bid["carbon_compensation"],
                "carbon_footprint": route["carbon_footprint"],  # 使用字典访问
                "estimated_days": math.ceil(route["estimated_time"] / 24),
                "route": route  # 已经是字典，无需再次转换
            }
            solutions.append(solution)
        
        economic = min(solutions, key=lambda x: x["price"])
        green = min(solutions, key=lambda x: x["carbon_footprint"])
        balanced = min(solutions, key=lambda x: x["price"] * 0.6 + 
                    (x["carbon_footprint"] / max(s["carbon_footprint"] for s in solutions)) * 0.4)
        
        optimized_solutions = [
            {**economic, "type": "economic"},
            {**green, "type": "green"},
            {**balanced, "type": "balanced"}
        ]
        bid["solutions"] = optimized_solutions
        bid["status"] = "completed"
        blockchain.add_transaction({"type": "solutions_generated", "bid_id": bid_id, "solutions": optimized_solutions})
        return optimized_solutions
    
    def _generate_bid_id(self, demand: Dict[str, Any]) -> str:
        return f"bid_{int(time.time())}_{demand['id']}"
    
    def _calculate_route(self, demand: Dict[str, Any], transport_type: str, carrier_id: str) -> TransportRoute:
        origin = demand["base_data"]["origin"]
        destination = demand["base_data"]["destination"]
        distance = calculate_distance(origin, destination)
        speed = self.transport_types[transport_type]["speed"]
        estimated_time = distance / speed
        carbon_footprint = fetch_carbon_footprint(distance, transport_type, demand["calculated_data"]["base_stu"])
        base_rate = self.transport_types[transport_type]["base_rate"]
        base_price = distance * base_rate * demand["calculated_data"]["base_stu"]
        return TransportRoute(origin, destination, transport_type, distance, carrier_id, 
                             estimated_time, carbon_footprint, base_price)
    
    def get_bid_status(self, bid_id: str) -> Optional[Dict[str, Any]]:
        if bid_id not in self.bids:
            return None
        bid = self.bids[bid_id]
        return {
            "id": bid["id"],
            "status": bid["status"],
            "first_round_count": len(bid["first_round_bids"]),
            "second_round_count": len(bid["second_round_bids"]),
            "solutions": bid["solutions"]
        }

bidding_system = BiddingSystem()

def start_bidding(*args, **kwargs) -> str:
    return bidding_system.start_bidding(*args, **kwargs)

def get_bid_status(*args, **kwargs) -> Optional[Dict[str, Any]]:
    return bidding_system.get_bid_status(*args, **kwargs)

================
File: blockchain.py
================
import time
import hashlib
import json
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
import random
from datetime import datetime

@dataclass
class Block:
    """区块结构"""
    index: int
    timestamp: float
    transactions: List[Dict[str, Any]]
    previous_hash: str
    nonce: int = 0
    hash: str = ""
    
    def calculate_hash(self) -> str:
        """计算区块哈希"""
        block_string = json.dumps({
            "index": self.index,
            "timestamp": self.timestamp,
            "transactions": self.transactions,
            "previous_hash": self.previous_hash,
            "nonce": self.nonce
        }, sort_keys=True)
        return hashlib.sha256(block_string.encode()).hexdigest()

@dataclass
class Node:
    """节点结构"""
    id: str
    node_type: str  # "super_node", "warehouse", "carrier", "merchant"
    stake: float = 0.0  # 质押代币数量
    credit_score: float = 8.0  # 初始信用分
    location: str = ""
    last_active: float = time.time()

class Blockchain:
    def __init__(self):
        self.chain: List[Block] = []
        self.pending_transactions: List[Dict] = []
        self.nodes: Dict[str, Node] = {}
        self.difficulty = 4  # PoW难度
        
        # 创建创世区块
        self.create_genesis_block()
        
        # 初始化一些测试节点
        self._init_test_nodes()
    
    def create_genesis_block(self) -> None:
        """创建创世区块"""
        genesis_block = Block(
            index=0,
            timestamp=time.time(),
            transactions=[{"type": "genesis", "data": "Genesis Block"}],
            previous_hash="0"
        )
        genesis_block.hash = genesis_block.calculate_hash()
        self.chain.append(genesis_block)
    
    def _init_test_nodes(self) -> None:
        """初始化测试节点"""
        # 添加超级节点
        for i in range(3):
            node_id = f"SuperNode_{chr(65+i)}"  # SuperNode_A, SuperNode_B, ...
            self.add_node(node_id, "super_node", stake=1000.0, location="Shanghai")
        
        # 添加仓储节点
        warehouses = ["Shanghai", "Singapore", "Bangkok"]
        for i, location in enumerate(warehouses):
            node_id = f"Warehouse_{i+1}"
            self.add_node(node_id, "warehouse", stake=500.0, location=location)
        
        # 添加承运商节点
        carriers = ["sea", "land", "air"]
        for i, carrier_type in enumerate(carriers):
            node_id = f"Carrier_{carrier_type.capitalize()}"
            self.add_node(node_id, "carrier", stake=800.0)
            self.nodes[node_id].credit_score = 8.0  # 强制重置信用分
        # 添加测试用 Carrier_1, Carrier_2, Carrier_3
        for i in range(1, 4):
            node_id = f"Carrier_{i}"
            self.add_node(node_id, "carrier", stake=800.0)
            self.nodes[node_id].credit_score = 8.0  # 确保信用分正常
        
        # 添加商家节点
        for i in range(2):
            node_id = f"Merchant_{i+1}"
            self.add_node(node_id, "merchant", stake=300.0)
    
    def add_node(self, node_id: str, node_type: str, 
                stake: float = 0.0, location: str = "") -> None:
        """添加新节点"""
        if node_id not in self.nodes:
            self.nodes[node_id] = Node(
                id=node_id,
                node_type=node_type,
                stake=stake,
                location=location
            )
    
    def add_transaction(self, transaction: Dict[str, Any]) -> int:
        """添加新交易到待处理池"""
        self.pending_transactions.append({
            **transaction,
            "timestamp": time.time()
        })
        return self.get_last_block().index + 1
    
    def mine_pending_transactions(self, miner_node_id: str) -> Optional[Block]:
        if not self.pending_transactions:
            return None
        
        if miner_node_id not in self.nodes:
            raise ValueError("Invalid miner node ID")
        
        print("Debug: Pending transactions:", self.pending_transactions)  # 添加调试
        
        last_block = self.get_last_block()
        new_block = Block(
            index=last_block.index + 1,
            timestamp=time.time(),
            transactions=self.pending_transactions.copy(),
            previous_hash=last_block.hash
        )
        
        # 工作量证明
        new_block = self.proof_of_work(new_block)
        
        # 添加挖矿奖励交易
        reward_transaction = {
            "type": "mining_reward",
            "miner": miner_node_id,
            "amount": self.get_mining_reward(),
            "timestamp": time.time()
        }
        new_block.transactions.append(reward_transaction)
        
        # 更新节点最后活动时间
        self.nodes[miner_node_id].last_active = time.time()
        
        # 将新区块添加到链上
        self.chain.append(new_block)
        
        # 清空待处理交易池
        self.pending_transactions = []
        
        return new_block
    
    def proof_of_work(self, block: Block) -> Block:
        """
        工作量证明
        
        Args:
            block: 待挖掘区块
            
        Returns:
            完成工作量证明的区块
        """
        block.nonce = 0
        calculated_hash = block.calculate_hash()
        
        while not calculated_hash.startswith('0' * self.difficulty):
            block.nonce += 1
            calculated_hash = block.calculate_hash()
        
        block.hash = calculated_hash
        return block
    
    def get_mining_reward(self) -> float:
        """计算挖矿奖励"""
        base_reward = 10.0
        # 根据链长度调整奖励
        return base_reward * (0.95 ** (len(self.chain) // 100))
    
    def is_chain_valid(self) -> bool:
        """验证区块链的有效性"""
        for i in range(1, len(self.chain)):
            current_block = self.chain[i]
            previous_block = self.chain[i-1]
            
            # 验证当前区块哈希
            if current_block.hash != current_block.calculate_hash():
                return False
            
            # 验证区块链接
            if current_block.previous_hash != previous_block.hash:
                return False
        
        return True
    
    def get_last_block(self) -> Block:
        """获取最后一个区块"""
        return self.chain[-1]
    
    def get_node_balance(self, node_id: str) -> float:
        """获取节点代币余额"""
        if node_id not in self.nodes:
            return 0.0
            
        balance = self.nodes[node_id].stake
        
        # 遍历所有区块的交易
        for block in self.chain:
            for tx in block.transactions:
                if tx["type"] == "mining_reward" and tx["miner"] == node_id:
                    balance += tx["amount"]
                elif tx["type"] == "transfer":
                    if tx.get("from") == node_id:
                        balance -= tx.get("amount", 0)
                    if tx.get("to") == node_id:
                        balance += tx.get("amount", 0)
        
        return balance
    
    def get_node_credit_score(self, node_id: str) -> float:
        """获取节点信用分"""
        if node_id not in self.nodes:
            return 0.0
        return self.nodes[node_id].credit_score
    
    def update_node_credit_score(self, node_id: str, 
                               score_change: float) -> None:
        """更新节点信用分"""
        if node_id in self.nodes:
            self.nodes[node_id].credit_score = max(0.0, min(10.0, 
                self.nodes[node_id].credit_score + score_change))
    
    def select_super_node(self) -> Optional[str]:
        """选择超级节点（用于出块）"""
        super_nodes = [
            node_id for node_id, node in self.nodes.items()
            if node.node_type == "super_node"
        ]
        
        if not super_nodes:
            return None
            
        # 基于质押量和信用分加权选择
        weights = []
        for node_id in super_nodes:
            node = self.nodes[node_id]
            weight = node.stake * node.credit_score
            weights.append(weight)
            
        return random.choices(super_nodes, weights=weights, k=1)[0]
    
    def get_chain_stats(self) -> Dict[str, Any]:
        """获取区块链统计信息"""
        return {
            "block_count": len(self.chain),
            "transaction_count": sum(
                len(block.transactions) for block in self.chain
            ),
            "node_count": len(self.nodes),
            "super_node_count": len([
                node for node in self.nodes.values()
                if node.node_type == "super_node"
            ]),
            "average_block_time": self._calculate_average_block_time(),
            "total_stake": sum(node.stake for node in self.nodes.values())
        }
    
    def _calculate_average_block_time(self) -> float:
        """计算平均出块时间"""
        if len(self.chain) < 2:
            return 0.0
            
        total_time = self.chain[-1].timestamp - self.chain[0].timestamp
        return total_time / (len(self.chain) - 1)
    
    def get_node_transactions(self, node_id: str, 
                            limit: int = 10) -> List[Dict[str, Any]]:
        """获取节点相关的交易"""
        transactions = []
        for block in reversed(self.chain):
            for tx in block.transactions:
                if (tx.get("from") == node_id or 
                    tx.get("to") == node_id or 
                    tx.get("miner") == node_id):
                    transactions.append({
                        **tx,
                        "block_index": block.index,
                        "block_hash": block.hash
                    })
                if len(transactions) >= limit:
                    return transactions
        return transactions

# 创建全局区块链实例
blockchain = Blockchain()

================
File: demand.py
================
from typing import Dict, Any, List, Optional
import hashlib
import json
import time
from datetime import datetime
from api import calculate_distance, verify_compliance
from dataclasses import dataclass
import math
from blockchain import blockchain  # 添加导入

@dataclass
class CLPItem:
    """集装箱装箱单物品"""
    name: str
    quantity: int
    weight: float
    volume: float
    category: str
    dangerous: bool = False

class DemandProcessor:
    def __init__(self):
        self.demands: Dict[str, Dict] = {}
        self.stu_factors = {"普通货物": 1.0, "易碎品": 1.2, "冷链": 1.3, "危险品": 1.5}
        self.time_factors = {"标准型 (5-7天)": 1.0, "加急型 (3天)": 1.4, "超急型 (24小时)": 2.0}
    
    def process_demand(self, weight: float, volume: float, origin: str, destination: str,
                      cargo_type: str = "普通货物", delivery_time: str = "标准型 (5-7天)",
                      clp_items: List[Dict] = None, merchant_id: str = "Merchant_1") -> Dict[str, Any]:
        """
        处理并标准化物流需求，包含身份验证
        
        Args:
            weight: 重量(kg)
            volume: 体积(m³)
            origin: 始发地
            destination: 目的地
            cargo_type: 货物类型
            delivery_time: 期望时效
            clp_items: CLP物品列表
            merchant_id: 商家ID
            
        Returns:
            标准化的需求数据
        """
        print("Debug: blockchain is", blockchain)  # 添加调试输出
        
        # 输入验证
        if weight <= 0 or volume <= 0:
            raise ValueError("Weight and volume must be positive")
        if cargo_type not in self.stu_factors:
            raise ValueError(f"Unknown cargo type: {cargo_type}")
        if delivery_time not in self.time_factors:
            raise ValueError(f"Unknown delivery time: {delivery_time}")
        
        # 身份验证
        if not verify_compliance(merchant_id, weight * 0.1, "demand_submission"):  # 假设0.1为估算金额
            raise ValueError(f"Merchant {merchant_id} failed compliance check")
        
        # 计算基础STU
        base_stu = max(weight / 1000, volume / 3)
        adjusted_stu = base_stu * self.stu_factors[cargo_type] * self.time_factors[delivery_time]
        
        # 计算距离
        distance = calculate_distance(origin, destination)
        
        # 验证CLP并生成签名
        clp_valid = self._validate_clp(clp_items) if clp_items else False
        clp_signature = self._generate_clp_signature(clp_items) if clp_items else "N/A"
        
        # 生成需求ID
        demand_id = self._generate_demand_id(weight, volume, origin, destination, time.time())
        
        # 构建需求对象
        demand = {
            "id": demand_id,
            "timestamp": datetime.now().isoformat(),
            "status": "pending",
            "merchant_id": merchant_id,
            "base_data": {
                "weight": weight,
                "volume": volume,
                "origin": origin,
                "destination": destination,
                "cargo_type": cargo_type,
                "delivery_time": delivery_time
            },
            "calculated_data": {
                "base_stu": base_stu,
                "adjusted_stu": adjusted_stu,
                "distance": distance,
                "estimated_base_cost": self._estimate_base_cost(adjusted_stu, distance)
            },
            "clp_data": {
                "valid": clp_valid,
                "items": clp_items,
                "signature": clp_signature,
                "verification_time": datetime.now().isoformat()
            }
        }
        
        # 存储并记录到区块链
        self.demands[demand_id] = demand
        blockchain.add_transaction({"type": "demand", "data": demand})
        return demand
    
    def _validate_clp(self, clp_items: List[Dict]) -> bool:
        """验证CLP物品列表"""
        try:
            total_weight = sum(item["weight"] * item["quantity"] for item in clp_items)
            total_volume = sum(item["volume"] * item["quantity"] for item in clp_items)
            
            if total_weight <= 0 or total_volume <= 0 or total_weight > 28000 or total_volume > 67.7:
                return False
            
            for item in clp_items:
                if item.get("dangerous", False):
                    if not verify_compliance("system", total_weight, "dangerous_goods"):
                        return False
            return True
        except Exception as e:
            print(f"CLP validation error: {str(e)}")
            return False
    
    def _generate_clp_signature(self, clp_items: List[Dict]) -> str:
        """生成CLP签名（模拟）"""
        clp_string = json.dumps(clp_items, sort_keys=True)
        return hashlib.sha256(clp_string.encode()).hexdigest()
    
    def _generate_demand_id(self, weight: float, volume: float, origin: str, 
                           destination: str, timestamp: float) -> str:
        data = f"{weight}{volume}{origin}{destination}{timestamp}"
        return hashlib.sha256(data.encode()).hexdigest()[:16]
    
    def _estimate_base_cost(self, stu: float, distance: float) -> float:
        return stu * distance * 0.1 + 50 + (stu * 10)
    
    def update_demand_status(self, demand_id: str, status: str) -> None:
        if demand_id in self.demands:
            self.demands[demand_id]["status"] = status
            self.demands[demand_id]["last_updated"] = datetime.now().isoformat()
    
    def get_demand(self, demand_id: str) -> Optional[Dict[str, Any]]:
        return self.demands.get(demand_id)
    
    def list_active_demands(self) -> List[Dict[str, Any]]:
        return [d for d in self.demands.values() if d["status"] in ["pending", "bidding", "processing"]]
    
    def get_demand_statistics(self) -> Dict[str, Any]:
        total_demands = len(self.demands)
        active_demands = len(self.list_active_demands())
        total_stu = sum(d["calculated_data"]["adjusted_stu"] for d in self.demands.values())
        return {
            "total_demands": total_demands,
            "active_demands": active_demands,
            "total_stu": total_stu,
            "average_stu": total_stu / total_demands if total_demands > 0 else 0
        }

demand_processor = DemandProcessor()

def process_demand(*args, **kwargs) -> Dict[str, Any]:
    return demand_processor.process_demand(*args, **kwargs)

def validate_clp(clp_items: List[Dict]) -> bool:
    return demand_processor._validate_clp(clp_items)

def get_demand_stats() -> Dict[str, Any]:
    return demand_processor.get_demand_statistics()

================
File: main.py
================
import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime
from typing import Dict, Any, List
import json

from blockchain import blockchain
from testnet import TestnetLedger
from demand import process_demand, validate_clp
from bidding import start_bidding, get_bid_status, bidding_system
from tokens import token_system
from payment import PaymentStage
from payment import PaymentSystem
from visuals import LogisticsVisualizer
from api import calculate_distance, fetch_carbon_footprint
import api  # 导入 api 模块以设置 global_payment_system

class LogisticsApp:
    def __init__(self):
        self.visualizer = LogisticsVisualizer()
        if 'initialized' not in st.session_state:
            self._init_session_state()
        api.global_payment_system = st.session_state.payment_system  # 设置 api.py 中的全局变量
    
    def _init_session_state(self):
        st.session_state.initialized = True
        st.session_state.mode = "pseudo"
        st.session_state.testnet = TestnetLedger()
        st.session_state.bidding_system = bidding_system  # 使用全局实例
        st.session_state.token_system = token_system      # 使用全局实例
        st.session_state.payment_system = PaymentSystem()
        st.session_state.current_demand = None
        st.session_state.current_bid_id = None
        st.session_state.current_solutions = None
        st.session_state.selected_solution = None
        st.session_state.current_payment_id = None  # 初始化 current_payment_id
    
    def run(self):
        st.title("跨境电商物流Demo")
        self._render_sidebar()
        tab1, tab2, tab3, tab4 = st.tabs(["需求发布", "竞价方案", "支付管理", "系统状态"])
        
        with tab1:
            self._render_demand_tab()
        with tab2:
            self._render_bidding_tab()
        with tab3:
            self._render_payment_tab()
        with tab4:
            self._render_status_tab()
    
    def _render_sidebar(self):
        st.sidebar.title("系统设置")
        mode = st.sidebar.selectbox(
            "选择运行模式",
            ["伪分布式模式", "测试网模式"],
            index=0 if st.session_state.mode == "pseudo" else 1
        )
        st.session_state.mode = "pseudo" if mode == "伪分布式模式" else "testnet"
        
        if st.session_state.mode == "pseudo":
            stats = blockchain.get_chain_stats()
            st.sidebar.write(f"区块数: {stats['block_count']}")
            st.sidebar.write(f"节点数: {stats['node_count']}")
        else:
            status = st.session_state.testnet.get_network_status()
            st.sidebar.write(f"网络: {status['network']}")
            st.sidebar.write(f"区块高度: {status.get('block_number', 'N/A')}")
        
        token_stats = token_system.get_stats()
        st.sidebar.write("---")
        st.sidebar.write("代币系统状态")
        st.sidebar.write(f"流通量: {token_stats['circulation']:.2f}")
        st.sidebar.write(f"碳补偿总量: {token_stats['carbon_offset']:.2f}")
    
    def _render_demand_tab(self):
        st.header("物流需求发布")
        with st.form("logistics_demand"):
            col1, col2 = st.columns(2)
            with col1:
                weight = st.number_input("重量 (kg)", min_value=0.1, value=1000.0)
                origin = st.text_input("始发地", value="Shanghai")
                delivery_time = st.selectbox(
                    "期望时效",
                    ["标准型 (5-7天)", "加急型 (3天)", "超急型 (24小时)"]
                )
            with col2:
                volume = st.number_input("体积 (m³)", min_value=0.1, value=5.0)
                destination = st.text_input("目的地", value="Singapore")
                cargo_type = st.selectbox(
                    "货物类型",
                    ["普通货物", "易碎品", "冷链", "危险品"]
                )
            st.subheader("CLP信息")
            clp_items = st.text_area(
                "输入CLP物品列表 (JSON格式)",
                value=json.dumps([
                    {"name": "Sample Item", "quantity": 100, "weight": 10, 
                     "volume": 0.05, "category": "普通货物", "dangerous": False}
                ], indent=2, ensure_ascii=False)
            )
            submitted = st.form_submit_button("提交需求")
            
            if submitted:
                try:
                    clp_data = json.loads(clp_items)
                    if validate_clp(clp_data):
                        demand = process_demand(
                            weight=weight, volume=volume, origin=origin,
                            destination=destination, cargo_type=cargo_type,
                            delivery_time=delivery_time, clp_items=clp_data
                        )
                        if st.session_state.mode == "pseudo":
                            blockchain.add_transaction({"type": "demand", "data": demand})
                            blockchain.mine_pending_transactions("SuperNode_A")
                        else:
                            tx_hash = st.session_state.testnet.post_demand(demand)
                            st.info(f"需求已记录到区块链: {tx_hash}")
                        st.session_state.current_demand = demand
                        bid_id = start_bidding(demand)
                        st.session_state.current_bid_id = bid_id
                        st.success(f"需求已提交并开始竞价! 竞价ID: {bid_id}")
                    else:
                        st.error("CLP验证失败!")
                except Exception as e:
                    st.error(f"处理需求时出错: {str(e)}")
    
    def _render_bidding_tab(self):
        st.header("竞价方案")
        if st.session_state.current_demand is None or st.session_state.current_bid_id is None:
            st.info("请先提交物流需求")
            return
        
        bid_status = get_bid_status(st.session_state.current_bid_id)
        if not bid_status:
            st.error("获取竞价状态失败")
            return
        
        st.write("竞价状态:", bid_status["status"])
        
        # 第一轮竞价
        if bid_status["status"] == "first_round":
            if st.button("模拟第一轮竞价"):
                for i in range(3):
                    bidding_system.submit_first_round_bid(
                        st.session_state.current_bid_id, f"Carrier_{i+1}",
                        base_price=1000 + i * 200, transport_type="sea"
                    )
                # 确保进入第二轮
                success = bidding_system.start_second_round(st.session_state.current_bid_id)
                if success:
                    st.success("第一轮竞价完成，已进入第二轮")
                else:
                    st.error("无法进入第二轮竞价，可能是投标数量不足")
                st.rerun()
        
        # 第二轮竞价
        if bid_status["status"] == "second_round":
            if st.button("模拟第二轮竞价并生成方案"):
                for i in range(3):
                    success = bidding_system.submit_second_round_bid(
                        st.session_state.current_bid_id, f"Carrier_{i+1}",
                        final_price=1100 + i * 200, carbon_compensation=100
                    )
                    if not success:
                        st.error(f"Carrier_{i+1} 第二轮竞价提交失败")
                        return
                solutions = bidding_system.generate_solutions(st.session_state.current_bid_id)
                st.session_state.current_solutions = solutions
                st.success("第二轮竞价完成，方案已生成")
                st.rerun()
        
        # 方案选择
        if bid_status["status"] == "completed" and st.session_state.current_solutions:
            df = pd.DataFrame(st.session_state.current_solutions)
            df['route'] = df['route'].apply(lambda r: f"{r['origin']} -> {r['destination']} ({r['transport_type']})")
            st.dataframe(df)
            fig = self.visualizer.plot_solutions(st.session_state.current_solutions)
            st.pyplot(fig)
            selected_index = st.selectbox(
                "选择方案",
                range(len(st.session_state.current_solutions)),
                format_func=lambda x: f"方案 {x+1}: {st.session_state.current_solutions[x]['type']}"
            )
            if st.button("确认方案"):
                selected_solution = st.session_state.current_solutions[selected_index]
                st.session_state.selected_solution = selected_solution
                payment_id = st.session_state.payment_system.create_payment(
                    selected_solution, "Merchant_1"
                )
                st.session_state.current_payment_id = payment_id
                if st.session_state.mode == "pseudo":
                    blockchain.add_transaction({"type": "solution_selected", "solution": selected_solution})
                    blockchain.mine_pending_transactions("SuperNode_A")
                else:
                    tx_hash = st.session_state.testnet.post_solution(selected_solution, payment_id)
                    st.info(f"方案已记录到区块链: {tx_hash}")
                st.success("方案已确认，支付订单已创建!")
    
    def _render_payment_tab(self):
        st.header("支付管理")
        if st.session_state.current_payment_id is None:
            st.info("请先确认一个方案")
            return
        
        # 强制获取最新的支付状态
        payment_status = st.session_state.payment_system.get_payment_status(st.session_state.current_payment_id)
        if not payment_status:
            st.error("获取支付状态失败")
            return
        
        st.write("Debug: Payment status before rendering:", payment_status)
        st.json(payment_status)
        
        # 将 current_stage 转换为索引
        stages = ["warehouse", "customs", "transport", "delivery"]
        stage_to_index = {stage: idx for idx, stage in enumerate(stages)}
        st.write("Debug: stage_to_index:", stage_to_index)
        
        # 清理 current_stage 字符串，确保没有额外的空格或不可见字符
        current_stage = payment_status["current_stage"].strip()
        st.write("Debug: payment_status['current_stage'] (after strip):", current_stage)
        
        # 检查 current_stage 是否在 stage_to_index 中
        if current_stage not in stage_to_index:
            st.error(f"Invalid current_stage: {current_stage}. Expected one of {stages}")
            current_stage_index = 0
        else:
            current_stage_index = stage_to_index[current_stage]
        st.write("Debug: Current stage index:", current_stage_index)
        
        # 渲染物流状态图
        st.write("Debug: Passing to plot_logistics_status:", {"current_stage": current_stage_index})
        fig = self.visualizer.plot_logistics_status({"current_stage": current_stage_index})
        # 移除 key 参数
        st.pyplot(fig)
        
        if payment_status["status"] != "completed":
            if st.button("触发下一阶段支付"):
                try:
                    # 调用 advance_payment
                    success = st.session_state.payment_system.advance_payment(st.session_state.current_payment_id)
                    if success:
                        if st.session_state.mode == "pseudo":
                            blockchain.add_transaction({"type": "payment_update", "payment_id": st.session_state.current_payment_id})
                            blockchain.mine_pending_transactions("SuperNode_A")
                        else:
                            tx_hash = st.session_state.testnet.trigger_payment(
                                {"demand_id": st.session_state.current_demand["id"], 
                                 "stage": payment_status["current_stage"], "amount": payment_status["total_amount"] * 0.3}
                            )
                            st.info(f"支付更新已记录到区块链: {tx_hash}")
                        st.success("支付状态已更新!")
                        # 强制刷新页面
                        st.rerun()
                    else:
                        st.error("支付失败，请检查物流状态")
                except Exception as e:
                    st.error(f"支付触发失败，错误信息：{str(e)}")
                    raise  # 重新抛出异常以便在终端显示堆栈
    
    def _render_status_tab(self):
        st.header("系统状态")
        col1, col2 = st.columns(2)
        with col1:
            st.subheader("账本状态")
            if st.session_state.mode == "pseudo":
                stats = blockchain.get_chain_stats()
                st.write(f"区块数: {stats['block_count']}")
                st.write(f"交易数: {stats['transaction_count']}")
                st.write(f"节点数: {stats['node_count']}")
            else:
                status = st.session_state.testnet.get_network_status()
                st.write(f"网络: {status['network']}")
                st.write(f"区块高度: {status.get('block_number', 'N/A')}")
        with col2:
            st.subheader("代币系统")
            token_stats = token_system.get_stats()
            st.write(f"总发行量: {token_stats['total_supply']:.2f}")
            st.write(f"流通量: {token_stats['circulation']:.2f}")
            st.write(f"碳补偿总量: {token_stats['carbon_offset']:.2f}")
        
        st.subheader("代币流动")
        flow_data = token_system.get_flow_data()
        fig = self.visualizer.plot_token_flow(flow_data)
        st.pyplot(fig)
        
        st.subheader("碳排放分析")
        carbon_data = token_system.get_carbon_data()
        fig = self.visualizer.plot_carbon_analysis(carbon_data)
        st.pyplot(fig)

if __name__ == "__main__":
    app = LogisticsApp()
    app.run()

================
File: payment.py
================
from typing import Dict, Any, List, Optional
import time
from datetime import datetime
import hashlib
import json
from enum import Enum
from api import verify_compliance, check_logistics_status
from blockchain import blockchain

# 确保这些定义在文件顶部，且没有缩进到其他类或方法中
class PaymentStatus(Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    REFUNDED = "refunded"

    def to_json(self):
        """将 PaymentStatus 转换为可序列化的字符串"""
        return self.value

class PaymentStage(Enum):
    WAREHOUSE = "warehouse"
    CUSTOMS = "customs"
    TRANSPORT = "transport"
    DELIVERY = "delivery"

    def to_json(self):
        """将 PaymentStage 转换为可序列化的字符串"""
        return self.value

class PaymentSystem:
    def __init__(self):
        self.payments: Dict[str, Dict] = {}
        self.stage_weights = {
            PaymentStage.WAREHOUSE: 0.3,
            PaymentStage.CUSTOMS: 0.4,
            PaymentStage.TRANSPORT: 0.2,
            PaymentStage.DELIVERY: 0.1
        }
    
    def create_payment(self, solution: Dict[str, Any], payer_id: str, currency: str = "USD") -> str:
        print("Debug: Creating payment for solution:", solution)
        payment_id = self._generate_payment_id(solution, payer_id)
        total_amount = solution["price"]
        stage_amounts = {stage.to_json(): total_amount * weight for stage, weight in self.stage_weights.items()}
        
        payment = {
            "id": payment_id,
            "solution_id": solution["carrier_id"],  # 简化，使用carrier_id
            "payer_id": payer_id,
            "carrier_id": solution["carrier_id"],
            "total_amount": total_amount,
            "currency": currency,
            "stage_amounts": stage_amounts,
            "paid_amounts": {},
            "current_stage": PaymentStage.WAREHOUSE.to_json(),  # 转换为字符串
            "status": PaymentStatus.PENDING.to_json(),  # 转换为字符串
            "created_at": datetime.now().isoformat(),
            "updated_at": datetime.now().isoformat(),
            "completed_at": None,
            "stage_timestamps": {},
            "refund_info": None,
            "solution": solution  # 存储 solution 以便后续使用
        }
        self.payments[payment_id] = payment
        blockchain.add_transaction({"type": "payment_created", "data": payment})
        print("Debug: Payment created with ID:", payment_id)
        return payment_id
    
    def _generate_payment_id(self, solution: Dict, payer_id: str) -> str:
        data = f"{solution['carrier_id']}{payer_id}{time.time()}"
        return f"pay_{hashlib.sha256(data.encode()).hexdigest()[:8]}"
    
    def advance_payment(self, payment_id: str) -> bool:
        print("Debug: Entering advance_payment with payment_id:", payment_id)
        if payment_id not in self.payments:
            print("Debug: Payment ID not found:", payment_id)
            return False
        
        # 调试：检查 PaymentStage 和 PaymentStatus 是否可用
        print("Debug: Checking PaymentStage in advance_payment...")
        print("Debug: globals() keys:", list(globals().keys()))
        print("Debug: PaymentStage in globals():", 'PaymentStage' in globals())
        print("Debug: PaymentStatus in globals():", 'PaymentStatus' in globals())
        
        payment = self.payments[payment_id]
        print("Debug: Payment details:", payment)
        
        if payment["status"] == PaymentStatus.COMPLETED.to_json():
            print("Debug: Payment already completed:", payment_id)
            return False
        
        # 模拟物流状态检查
        print("Debug: Checking logistics status for stage:", payment["current_stage"])
        tracking_status = check_logistics_status(payment_id)
        print("Debug: Tracking status:", tracking_status)
        if tracking_status["current_stage"] != payment["current_stage"]:
            print("Debug: Logistics stage mismatch. Expected:", payment["current_stage"], "Got:", tracking_status["current_stage"])
            return False
        
        # 计算当前阶段的支付金额
        stage = payment["current_stage"]
        print("Debug: Current stage:", stage)
        try:
            stage_percentage = self.stage_weights[PaymentStage(stage)]
        except Exception as e:
            print(f"Debug: Error accessing PaymentStage: {str(e)}")
            raise
        stage_amount = payment["total_amount"] * stage_percentage
        print("Debug: Stage percentage:", stage_percentage, "Stage amount:", stage_amount)
        
        # 更新支付状态
        payment["paid_amounts"][stage] = stage_amount
        payment["remaining_amount"] = payment["total_amount"] - sum(payment["paid_amounts"].values())
        payment["updated_at"] = datetime.now().isoformat()
        
        # 推进到下一阶段
        try:
            stages = [stage.to_json() for stage in PaymentStage]
        except Exception as e:
            print(f"Debug: Error accessing PaymentStage for stages: {str(e)}")
            raise
        current_index = stages.index(payment["current_stage"])
        if current_index < len(stages) - 1:
            payment["current_stage"] = stages[current_index + 1]
        else:
            payment["status"] = PaymentStatus.COMPLETED.to_json()
        print("Debug: Updated current_stage to:", payment["current_stage"])
        
        # 记录碳补偿（在 delivery 阶段）
        try:
            if payment["current_stage"] == PaymentStage.DELIVERY.to_json() and payment["status"] != PaymentStatus.COMPLETED.to_json():
                carbon_compensation = payment.get("solution", {}).get("carbon_compensation", 0)
                print("Debug: Carbon compensation:", carbon_compensation)
                # tokens.compensate_carbon(carbon_compensation)
                pass
        except Exception as e:
            print(f"Debug: Error in carbon compensation block: {str(e)}")
            raise
        
        blockchain.add_transaction({"type": "payment_advanced", "payment": payment})
        print("Debug: Payment advanced successfully:", payment_id)
        
        # 同步物流状态
        # 必要性：支付系统在推进阶段后需要通知物流系统更新状态，以保持两者一致
        # 合理性：在模拟环境中，通过调用 update_logistics_status 模拟真实的物流系统状态更新
        try:
            from api import update_logistics_status
            update_logistics_status(payment_id, payment["current_stage"])
            print("Debug: Logistics status updated to:", payment["current_stage"])
        except ImportError as e:
            print(f"Debug: Failed to update logistics status: {str(e)}")
        
        return True
    
    def trigger_stage_payment(self, payment_id: str, stage: PaymentStage, proof: Dict[str, Any]) -> bool:
        print("Debug: Entering trigger_stage_payment with payment_id:", payment_id, "stage:", stage.to_json())
        if payment_id not in self.payments:
            print("Debug: Payment ID not found:", payment_id)
            return False
        payment = self.payments[payment_id]
        if payment["current_stage"] != stage.to_json() or payment["status"] != PaymentStatus.PENDING.to_json():
            print("Debug: Stage or status mismatch. Current stage:", payment["current_stage"], "Status:", payment["status"])
            return False
        
        # 身份验证
        if not verify_compliance(payment["payer_id"], payment["stage_amounts"][stage.to_json()], "payment"):
            print("Debug: Payer compliance check failed")
            return False
        if not verify_compliance(payment["carrier_id"], payment["stage_amounts"][stage.to_json()], "payment_receive"):
            print("Debug: Carrier compliance check failed")
            return False
        
        # 验证物流状态
        tracking_status = check_logistics_status(payment_id)
        print("Debug: Tracking status:", tracking_status)
        if not self._verify_payment_condition(stage, proof, tracking_status):
            print("Debug: Payment condition verification failed")
            print("Debug: Proof provided:", proof)
            print("Debug: Expected stage:", stage.to_json(), "Actual logistics stage:", tracking_status["current_stage"])
            return False
        
        amount = payment["stage_amounts"][stage.to_json()]
        if self._process_payment(payment_id, stage, amount):
            payment["paid_amounts"][stage.to_json()] = amount
            payment["stage_timestamps"][stage.to_json()] = datetime.now().isoformat()
            stages = list(PaymentStage)
            current_index = stages.index(stage)
            if current_index < len(stages) - 1:
                payment["current_stage"] = stages[current_index + 1].to_json()
            else:
                payment["status"] = PaymentStatus.COMPLETED.to_json()
                payment["completed_at"] = datetime.now().isoformat()
            payment["updated_at"] = datetime.now().isoformat()
            blockchain.add_transaction({
                "type": "payment_stage",
                "payment_id": payment_id,
                "stage": stage.to_json(),
                "amount": amount
            })
            print("Debug: Stage payment triggered successfully:", payment_id)
            return True
        print("Debug: Payment processing failed")
        return False
    
    def _verify_payment_condition(self, stage: PaymentStage, proof: Dict[str, Any], tracking_status: Dict) -> bool:
        stage_str = stage.to_json()
        print("Debug: Verifying payment condition for stage:", stage_str)
        if stage_str == PaymentStage.WAREHOUSE.to_json():
            result = proof.get("warehouse_receipt") and tracking_status["current_stage"] == "warehouse"
            print("Debug: Warehouse condition - warehouse_receipt:", proof.get("warehouse_receipt"), "stage match:", tracking_status["current_stage"] == "warehouse")
            return result
        elif stage_str == PaymentStage.CUSTOMS.to_json():
            result = all(k in proof for k in ["customs_declaration", "inspection_cert"]) and \
                     tracking_status["current_stage"] == "customs"
            print("Debug: Customs condition - customs_declaration:", "customs_declaration" in proof, 
                  "inspection_cert:", "inspection_cert" in proof, "stage match:", tracking_status["current_stage"] == "customs")
            return result
        elif stage_str == PaymentStage.TRANSPORT.to_json():
            result = proof.get("tracking_status") == "in_transit" and tracking_status["current_stage"] == "transport"
            print("Debug: Transport condition - tracking_status:", proof.get("tracking_status"), 
                  "stage match:", tracking_status["current_stage"] == "transport")
            return result
        elif stage_str == PaymentStage.DELIVERY.to_json():
            result = proof.get("delivery_confirmation") and tracking_status["current_stage"] == "delivery"
            print("Debug: Delivery condition - delivery_confirmation:", proof.get("delivery_confirmation"), 
                  "stage match:", tracking_status["current_stage"] == "delivery")
            return result
        return False
    
    def _process_payment(self, payment_id: str, stage: PaymentStage, amount: float) -> bool:
        print("Debug: Processing payment for payment_id:", payment_id, "stage:", stage.to_json(), "amount:", amount)
        return True  # 模拟支付成功
    
    def get_payment_status(self, payment_id: str) -> Optional[Dict[str, Any]]:
        print("Debug: Getting payment status for payment_id:", payment_id)
        if payment_id not in self.payments:
            print("Debug: Payment ID not found:", payment_id)
            return None
        payment = self.payments[payment_id]
        return {
            "id": payment["id"],
            "status": payment["status"],
            "current_stage": payment["current_stage"],
            "total_amount": payment["total_amount"],
            "paid_amount": sum(payment["paid_amounts"].values()),
            "remaining_amount": payment["total_amount"] - sum(payment["paid_amounts"].values()),
            "updated_at": payment["updated_at"]
        }
    
    def request_refund(self, payment_id: str, reason: str) -> bool:
        print("Debug: Requesting refund for payment_id:", payment_id)
        if payment_id not in self.payments or self.payments[payment_id]["status"] != PaymentStatus.COMPLETED.to_json():
            print("Debug: Cannot request refund, payment not completed or not found")
            return False
        payment = self.payments[payment_id]
        payment["refund_info"] = {
            "reason": reason,
            "requested_at": datetime.now().isoformat(),
            "status": "pending",
            "amount": sum(payment["paid_amounts"].values())
        }
        blockchain.add_transaction({"type": "refund_requested", "payment_id": payment_id, "reason": reason})
        print("Debug: Refund requested successfully:", payment_id)
        return True
    
    def process_refund(self, payment_id: str, approved: bool) -> bool:
        print("Debug: Processing refund for payment_id:", payment_id, "approved:", approved)
        if payment_id not in self.payments or not self.payments[payment_id].get("refund_info"):
            print("Debug: No refund info found for payment_id:", payment_id)
            return False
        payment = self.payments[payment_id]
        if payment["refund_info"]["status"] == "pending":
            payment["refund_info"]["status"] = "completed" if approved else "rejected"
            payment["refund_info"]["processed_at"] = datetime.now().isoformat()
            if approved:
                payment["status"] = PaymentStatus.REFUNDED.to_json()
            blockchain.add_transaction({"type": "refund_processed", "payment_id": payment_id, "approved": approved})
            print("Debug: Refund processed successfully:", payment_id)
            return True
        print("Debug: Refund not in pending state")
        return False
    
    def get_payment_history(self, payer_id: str) -> List[Dict[str, Any]]:
        print("Debug: Getting payment history for payer_id:", payer_id)
        return [p for p in self.payments.values() if p["payer_id"] == payer_id]
    
    def get_stage_statistics(self) -> Dict[str, Any]:
        print("Debug: Getting stage statistics")
        stats = {stage.to_json(): {"count": 0, "total_amount": 0} for stage in PaymentStage}
        for payment in self.payments.values():
            for stage, amount in payment["paid_amounts"].items():
                stats[stage]["count"] += 1
                stats[stage]["total_amount"] += amount
        return stats

================
File: README.md
================
---

# 跨境电商物流Demo

欢迎体验 **Cross-Border E-Commerce Logistics Demo**，这是一个基于区块链的原型项目，旨在革新东亚至东南亚跨境电商物流生态系统。本项目通过分布式账本技术优化跨境运输，替代传统货代公司（freight forwarders），实现透明、高效且环保的物流协同平台。专为金融科技竞赛设计，Demo展示了多阶段竞价（multi-stage bidding）、碳排放代币激励（carbon emission incentives）、自动化支付（automated payments）以及CLP集装箱装箱单（Container Loading Plan, CLP）验证等创新功能，并通过Streamlit界面提供直观交互和可视化效果。

---

## 项目概述

### 项目功能
本Demo模拟了一个公链平台，连接跨境电商商家、仓储公司、航运公司、地方货运公司和买家，通过分布式账本实现：
- **物流需求与供给匹配**：透明竞价系统提供最低报价方案。
- **绿色运输激励**：基于碳排放的代币奖励推动环保运输。
- **支付自动化**：与物流节点（如入仓、清关、签收）实时绑定。
- **分布式记录**：所有操作记录在分布式账本上，确保透明性和一致性。
- **API支持**：集成碳足迹、物流状态、合规性、地理信息和汇率接口。
- **身份验证**：通过CLP和其他机制验证链上角色身份。

### 核心技术亮点
1. **分布式账本（Distributed Ledger）**：
   - 伪分布式模拟：单机多节点协作，带伪共识机制。
   - 真实分布式支持：预留Ethereum Sepolia测试网接口。
2. **去中心化竞价（Decentralized Bidding）**：
   - 多阶段竞价（盲拍+优化）。
   - 多式联运优化（经济型、均衡型、绿色型方案）。
3. **代币经济（Token Economy）**：
   - 超级节点（Super Node）因维护账本获奖励。
   - 碳排放补偿激励绿色路径。
   - 信用评分（Credit Scoring）基于交易历史。
4. **智能支付（Smart Payments）**：
   - 分层架构（主链大额、侧链小额）。
   - 物流里程碑触发支付，含合规检查。
5. **API集成**：
   - 碳足迹计算、物流追踪、KYC/AML验证、距离计算、汇率转换。
6. **身份验证与CLP**：
   - 使用CLP集装箱装箱单验证需求、竞价和支付的真实性。
   - 支持模拟签名和未来数字签名/DID。
7. **可视化（Visualization）**：
   - Streamlit交互式UI。
   - 图表展示竞价方案和代币流动。

### 创新之处
- **去中介化**：去除货代中间商，降低18%-22%的物流成本。
- **碳减排**：经济激励与碳排放挂钩，单位运输碳排放下降25%-30%。
- **双模式账本**：支持伪分布式和真实分布式实现，兼顾演示与扩展性。
- **API与身份验证**：预留多种接口，结合CLP增强信任和合规性。

---

## 安装与运行

### 前置条件
- Python 3.8或以上版本
- Git（用于克隆仓库）
- （可选）Ethereum测试网账户和Infura密钥（用于真实分布式模式）

### 安装步骤
1. **克隆仓库**：
   ```bash
   git clone https://github.com/<你的用户名>/cross_border_logistics_demo.git
   cd cross_border_logistics_demo
   ```
2. **安装依赖**：
   ```bash
   pip install -r requirements.txt
   ```
   `requirements.txt`包含：
   - `streamlit`：网页交互界面。
   - `matplotlib`：数据可视化。
   - `pandas`：表格数据处理。
   - `web3`：Ethereum测试网交互。
   - `requests`：API调用支持。
   - `cryptography`：数字签名支持。
3. **运行Demo**：
   ```bash
   streamlit run main.py
   ```
   - 默认启动伪分布式模式，访问`http://localhost:8501`。
   - 若使用真实分布式模式，需配置`testnet.py`（见下方说明）。

### 真实分布式模式配置
- **Infura密钥**：注册Infura，获取Sepolia测试网URL。
- **Ethereum账户**：创建账户，获取地址和私钥，充值少量测试ETH。
- **合约部署**：使用Remix编译并部署提供的Solidity合约，记录地址和ABI。
- **修改`testnet.py`**：填入密钥、地址和ABI。

---

## 文件结构与功能

以下是每个文件的详细功能、技术实现路径及其与其他文件的关联。

### 1. `main.py`
- **功能**：
  - 主程序入口，运行Streamlit UI。
  - 支持两种账本模式：伪分布式（默认）和真实分布式（Ethereum测试网）。
  - 集成所有模块，展示完整流程，含CLP输入。
- **输入**：用户输入货运需求（重量、体积、始发地、目的地、时效、CLP物品列表）+模式选择。
- **输出**：标准化需求（STU）、竞价方案、代币余额、支付进度、图表。
- **技术路径**：
  - 使用`streamlit`创建交互界面。
  - 根据模式选择实例化`Blockchain`或`TestnetLedger`。
  - 调用各模块功能，展示API和CLP验证结果。
- **关系**：
  - **导入**：`demand.py`、`bidding.py`、`tokens.py`、`payment.py`、`visuals.py`、`blockchain.py`、`testnet.py`。
  - **调用**：
    - `post_demand`（需求处理）。
    - `simulate_bidding`和`optimize_routes`（竞价）。
    - `TokenSystem`方法（代币管理）。
    - `Payment`方法（支付触发）。
    - `plot_solutions`和`plot_tokens`（可视化）。

### 2. `blockchain.py`
- **功能**：
  - 实现伪分布式账本，模拟多节点协作。
  - 记录所有交易（需求、竞价、代币、支付），支持CLP和API数据。
- **输入**：交易数据（字典，如`{"type": "demand", "clp": {...}}`）。
- **输出**：新区块，广播给所有节点。
- **技术路径**：
  - 节点池：`nodes`列表模拟多个参与方。
  - 伪共识：基于规模和压力选择出块节点。
  - 广播：`node_ledgers`字典同步账本。
  - 使用`hashlib.sha256`确保不可篡改。
  - 记录CLP签名验证结果。
- **关系**：
  - **被导入**：`main.py`、`demand.py`、`bidding.py`、`tokens.py`、`payment.py`。
  - **作用**：作为伪分布式数据存储。

### 3. `demand.py`
- **功能**：
  - 处理货运需求，标准化为STU。
  - 调用地理信息API计算距离。
  - 验证CLP签名，确保需求真实性。
- **输入**：重量（kg）、体积（m³）、始发地、目的地、时效、商家ID、CLP物品列表。
- **输出**：STU值。
- **技术路径**：
  - 公式：`max(weight / 2000, volume / 68)`。
  - 调用`api.py`的`calculate_distance`。
  - 使用哈希验证CLP签名。
- **关系**：
  - **导入**：`blockchain.py`、`api.py`。
  - **调用**：`blockchain.py`或`testnet.py`的`add_block`。

### 4. `bidding.py`
- **功能**：
  - 模拟多节点竞价（盲拍）。
  - 调用碳足迹API获取碳排放数据。
  - 检查报价异常（防合谋）。
  - 验证CLP签名，确保竞价基于真实数据。
  - 优化多式联运方案（经济型、均衡型、绿色型）。
- **输入**：STU值、始发地、目的地、CLP对象。
- **输出**：方案字典（节点ID、价格、碳排放、时效）。
- **技术路径**：
  - 使用`random`生成报价。
  - 调用`api.py`的`fetch_carbon_footprint`。
  - `hashlib.sha256`隐藏报价（简版零知识证明）。
  - 验证CLP签名。
  - 加权评分优化方案。
- **关系**：
  - **导入**：`blockchain.py`、`api.py`。
  - **调用**：`blockchain.py`或`testnet.py`。
  - **提供数据**：碳排放给`tokens.py`。

### 5. `tokens.py`
- **功能**：
  - 管理代币经济：
    - 超级节点出块奖励。
    - 库存转移支付。
    - 碳排放补偿。
  - 维护信用评分和代币上限。
- **输入**：节点ID、货物体积、碳排放增量。
- **输出**：更新余额和评分。
- **技术路径**：
  - 字典存储余额和评分。
  - 检查`total_supply`上限。
  - 基于`bidding.py`的碳排放数据分配奖励。
- **关系**：
  - **导入**：`blockchain.py`。
  - **调用**：`blockchain.py`或`testnet.py`。
  - **使用**：`bidding.py`的碳排放数据。

### 6. `payment.py`
- **功能**：
  - 模拟分层支付（主链/侧链）。
  - 调用物流状态API验证节点状态。
  - 调用合规性API执行KYC/AML检查。
  - 调用汇率API转换货币。
  - 验证CLP签名，确保支付基于真实货物。
  - 触发支付（入仓30%、清关45%、签收30%）。
- **输入**：总金额、用户ID、追踪号、CLP对象。
- **输出**：支付金额（CNY和EUR）。
- **技术路径**：
  - 条件逻辑划分支付。
  - 调用`api.py`的`check_logistics_status`、`verify_compliance`、`get_exchange_rate`。
  - 使用哈希验证CLP签名。
- **关系**：
  - **导入**：`blockchain.py`、`api.py`。
  - **调用**：`blockchain.py`或`testnet.py`。

### 7. `visuals.py`
- **功能**：
  - 生成图表：
    - 方案对比（价格 vs 碳排放）。
    - 代币余额变化。
- **输入**：方案数据、代币余额。
- **输出**：Matplotlib图表。
- **技术路径**：
  - 使用`matplotlib`绘制。
  - 与`streamlit`集成。
- **关系**：
  - **导入**：`main.py`。
  - **使用**：`bidding.py`和`tokens.py`数据。

### 8. `testnet.py`
- **功能**：
  - 连接Ethereum Sepolia测试网。
  - 部署合约记录数据。
- **输入**：Infura URL、私钥、合约地址和ABI。
- **输出**：交易哈希。
- **技术路径**：
  - 使用`web3.py`与测试网交互。
  - 提供Solidity合约示例。
- **关系**：
  - **导入**：`main.py`（可选）。

### 9. `api.py`
- **功能**：
  - 提供API接口模拟，支持：
    - 碳足迹（`fetch_carbon_footprint`）。
    - 物流状态（`check_logistics_status`）。
    - 合规性（`verify_compliance`）。
    - 地理信息（`calculate_distance`）。
    - 汇率（`get_exchange_rate`）。
- **输入**：根据接口不同（如始发地、追踪号等）。
- **输出**：模拟数据（如碳排放量、状态布尔值等）。
- **技术路径**：
  - 使用`random`生成模拟值。
  - 定义明确的数据需求，预留真实API替换。
- **关系**：
  - **被导入**：`demand.py`、`bidding.py`、`payment.py`。

### 10. `requirements.txt`
- **功能**：列出依赖。
- **内容**：
  ```
  streamlit
  matplotlib
  pandas
  web3
  requests
  cryptography
  ```

### 11. `README.md`
- **功能**：本文档，指导用户和评委。

---

## 工作流程

1. **用户交互** (`main.py`)：
   - 输入需求（如12,000 kg，24 m³，上海到柏林，CLP物品列表）。
   - 选择账本模式（伪分布式/真实分布式）。
2. **需求处理** (`demand.py`)：
   - 转换为STU，调用API计算距离，验证CLP签名，记录到账本。
3. **竞价模拟** (`bidding.py`)：
   - 节点提交报价，调用API获取碳排放，验证CLP，检查合谋，优化方案。
4. **代币操作** (`tokens.py`)：
   - 奖励SuperNode_A，转移库存，基于碳排放补偿Transporter_B。
5. **支付执行** (`payment.py`)：
   - 调用API验证物流状态和合规性，验证CLP，转换汇率，触发支付。
6. **可视化** (`visuals.py`)：
   - 显示方案对比和代币图表。

---

## 技术实现路径

### 伪分布式账本（Pseudo-Distributed Ledger）
- **为何使用?**：快速模拟分布式特性，无需真实网络。
- **如何实现?**：
  - 节点池：`nodes`列表模拟多节点。
  - 伪共识：基于规模和压力选择出块节点。
  - 广播：`node_ledgers`同步账本。

### 真实分布式账本（Real Distributed Ledger）
- **为何使用?**：展示真实区块链潜力。
- **如何实现?**：
  - `web3.py`连接Sepolia测试网。
  - 部署Solidity合约记录数据。
  - 通过交易哈希验证上链。

### API接口模拟
- **碳足迹**：`fetch_carbon_footprint`模拟运输碳排放，输入始发地、目的地、重量、运输方式。
- **物流状态**：`check_logistics_status`模拟节点状态，输入追踪号和阶段。
- **合规性**：`verify_compliance`模拟KYC/AML，输入用户ID和金额。
- **地理信息**：`calculate_distance`模拟距离，输入始发地和目的地。
- **汇率**：`get_exchange_rate`模拟货币转换，输入源货币和目标货币。
- **实现方式**：使用`random`生成数据，预留真实API替换。

### 身份验证与CLP
- **验证场景**：
  - **需求发布**：验证商家CLP签名。
  - **竞价**：验证CLP确保报价真实。
  - **支付**：验证CLP匹配物流状态。
  - **角色注册**：验证节点身份。
- **Demo模拟手段**：
  - 使用`hashlib.sha256`生成和验证CLP签名。
  - 检查节点ID和信用评分。
- **真实实现手段**：
  - 使用`cryptography`实现数字签名（ECDSA）。
  - 结合DID（去中心化身份）或海关API验证。

### 其他模块
- **竞价**：随机数据+哈希匿名+API碳排放+CLP验证。
- **代币**：字典管理+上限检查+碳奖励。
- **支付**：条件触发+分层+API验证+CLP检查。

---

## 文件间关系

- **中心**：`main.py`协调所有模块。
- **账本**：`blockchain.py`（伪分布式）或`testnet.py`（真实分布式）作为数据核心。
- **API支持**：`api.py`为`demand.py`、`bidding.py`、`payment.py`提供数据。
- **流程**：
  - `demand.py` → `bidding.py` → `tokens.py` → `payment.py`。
  - `visuals.py`从`bidding.py`和`tokens.py`取数据。
- **切换**：`main.py`通过模式选择调用不同账本。

---

## 局限性与未来计划
- **伪分布式**：仅单机模拟，未实现真实网络通信。
- **真实分布式**：需手动配置测试网，合约功能有限。
- **API**：当前为模拟，需接入真实服务（如Carbon Interface）。
- **CLP验证**：当前为哈希模拟，未来需数字签名和海关验证。
- **未来**：
  - 完善共识机制（DPoS）。
  - 集成真实API和IoT。
  - 扩展NFT功能（资产证券化）。

---

================
File: requirements.txt
================
# Core dependencies
streamlit==1.31.0
pandas==2.2.0
numpy==1.24.3
web3==6.15.1

# Visualization
matplotlib==3.8.2
seaborn==0.13.2
plotly==5.18.0
networkx==3.2.1

# Blockchain and Cryptography
eth-account==0.11.0
eth-utils==2.3.1
cryptography==42.0.2

# Data Processing
python-dotenv==1.0.1
requests==2.31.0
PyYAML==6.0.1
jsonschema==4.21.1

# Date and Time
python-dateutil==2.8.2
pytz==2024.1

# Utilities
tqdm==4.66.2
six==1.16.0
typing-extensions==4.9.0

# Optional but recommended
ipython==8.12.0
jupyter==1.0.0

================
File: testnet.py
================
from typing import Dict, Any, Optional, List
import nest_asyncio
import asyncio

# 应用 nest_asyncio 来允许嵌套的事件循环
nest_asyncio.apply()

# 确保有一个事件循环在运行
try:
    loop = asyncio.get_event_loop()
except RuntimeError:
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)


from web3 import Web3
from eth_account import Account
import json
import os
from datetime import datetime
import asyncio
from eth_typing import Address
from web3.middleware import geth_poa_middleware
from dotenv import load_dotenv

class TestnetLedger:
    """
    真实分布式账本实现，连接Ethereum Sepolia测试网
    用于记录跨境物流相关的交易数据，包括需求、竞价、支付等
    """
    def __init__(self):
        # 加载环境变量
        load_dotenv()
        
        # 测试网配置
        self.network = {
            "name": "sepolia",
            "rpc_url": os.getenv("SEPOLIA_RPC_URL"),
            "chain_id": 11155111,
            "explorer": "https://sepolia.etherscan.io"
        }
        
        # 合约配置
        self.contracts = {
            "logistics": {
                "address": os.getenv("LOGISTICS_CONTRACT_ADDRESS"),
                "abi_path": "contracts/LogisticsContract.json"
            },
            "token": {
                "address": os.getenv("TOKEN_CONTRACT_ADDRESS"),
                "abi_path": "contracts/TokenContract.json"
            }
        }
        
        # Web3连接
        self.w3 = None
        self.account = None
        self._initialize_connection()

    def _initialize_connection(self) -> None:
        """初始化与测试网的连接"""
        try:
            self.w3 = Web3(Web3.HTTPProvider(self.network["rpc_url"]))
            self.w3.middleware_onion.inject(geth_poa_middleware, layer=0)
            
            if not self.w3.is_connected():
                raise ConnectionError("Failed to connect to Sepolia testnet")
                
            # 设置账户
            private_key = os.getenv("PRIVATE_KEY")
            if private_key:
                self.account = self.w3.eth.account.from_key(private_key)
                
        except Exception as e:
            print(f"Testnet connection failed: {str(e)}")

    def _load_contract_abi(self, contract_type: str) -> Dict:
        """加载智能合约ABI"""
        try:
            abi_path = self.contracts[contract_type]["abi_path"]
            with open(abi_path) as f:
                return json.load(f)
        except Exception as e:
            print(f"Failed to load ABI for {contract_type}: {str(e)}")
            return {}

    async def post_demand(self, demand_data: Dict[str, Any]) -> str:
        """
        发布物流需求到区块链
        
        Args:
            demand_data: 包含STU、始发地、目的地、CLP等信息的需求数据
            
        Returns:
            交易哈希
        """
        contract = self._get_contract("logistics")
        
        try:
            # 准备交易数据
            tx_data = contract.functions.postDemand(
                demand_data["stu"],
                demand_data["origin"],
                demand_data["destination"],
                Web3.to_hex(text=str(demand_data["clp"]))  # CLP数据上链
            ).build_transaction({
                'from': self.account.address,
                'nonce': self.w3.eth.get_transaction_count(self.account.address),
                'gas': 2000000,
                'gasPrice': self.w3.eth.gas_price
            })
            
            # 签名并发送交易
            signed_tx = self.account.sign_transaction(tx_data)
            tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
            
            # 等待交易确认
            receipt = await self._wait_for_transaction(tx_hash)
            return receipt['transactionHash'].hex()
            
        except Exception as e:
            print(f"Failed to post demand: {str(e)}")
            return None

    async def submit_bid(self, bid_data: Dict[str, Any]) -> str:
        """
        提交竞价方案到区块链
        
        Args:
            bid_data: 包含价格、碳排放、运输方式等信息的竞价数据
            
        Returns:
            交易哈希
        """
        contract = self._get_contract("logistics")
        
        try:
            tx_data = contract.functions.submitBid(
                bid_data["demand_id"],
                bid_data["price"],
                bid_data["carbon_emission"],
                bid_data["transport_type"],
                Web3.to_hex(text=str(bid_data["clp_verification"]))  # CLP验证结果
            ).build_transaction({
                'from': self.account.address,
                'nonce': self.w3.eth.get_transaction_count(self.account.address),
                'gas': 2000000,
                'gasPrice': self.w3.eth.gas_price
            })
            
            signed_tx = self.account.sign_transaction(tx_data)
            tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
            receipt = await self._wait_for_transaction(tx_hash)
            return receipt['transactionHash'].hex()
            
        except Exception as e:
            print(f"Failed to submit bid: {str(e)}")
            return None

    async def trigger_payment(self, payment_data: Dict[str, Any]) -> str:
        """
        触发支付交易
        
        Args:
            payment_data: 包含金额、阶段、验证信息等的支付数据
            
        Returns:
            交易哈希
        """
        contract = self._get_contract("logistics")
        
        try:
            tx_data = contract.functions.triggerPayment(
                payment_data["demand_id"],
                payment_data["stage"],
                payment_data["amount"],
                Web3.to_hex(text=str(payment_data["verification"]))
            ).build_transaction({
                'from': self.account.address,
                'nonce': self.w3.eth.get_transaction_count(self.account.address),
                'gas': 2000000,
                'gasPrice': self.w3.eth.gas_price
            })
            
            signed_tx = self.account.sign_transaction(tx_data)
            tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
            receipt = await self._wait_for_transaction(tx_hash)
            return receipt['transactionHash'].hex()
            
        except Exception as e:
            print(f"Failed to trigger payment: {str(e)}")
            return None

    def get_carbon_tokens(self, address: str) -> int:
        """获取地址的碳代币余额"""
        contract = self._get_contract("token")
        try:
            return contract.functions.balanceOf(address).call()
        except Exception as e:
            print(f"Failed to get token balance: {str(e)}")
            return 0

    def get_transaction_history(self, address: Optional[str] = None) -> List[Dict]:
        """获取交易历史"""
        if not address:
            address = self.account.address
            
        try:
            # 获取最近100个区块的交易
            end_block = self.w3.eth.block_number
            start_block = max(0, end_block - 100)
            
            transactions = []
            for block_num in range(start_block, end_block + 1):
                block = self.w3.eth.get_block(block_num, full_transactions=True)
                for tx in block.transactions:
                    if tx['to'] == address or tx['from'] == address:
                        transactions.append({
                            'hash': tx['hash'].hex(),
                            'from': tx['from'],
                            'to': tx['to'],
                            'value': self.w3.from_wei(tx['value'], 'ether'),
                            'block': block_num,
                            'timestamp': block.timestamp
                        })
            return transactions
            
        except Exception as e:
            print(f"Failed to get transaction history: {str(e)}")
            return []

    def _get_contract(self, contract_type: str):
        """获取合约实例"""
        if contract_type not in self.contracts:
            raise ValueError(f"Unknown contract type: {contract_type}")
            
        address = self.contracts[contract_type]["address"]
        abi = self._load_contract_abi(contract_type)
        
        return self.w3.eth.contract(
            address=self.w3.to_checksum_address(address),
            abi=abi
        )

    async def _wait_for_transaction(self, tx_hash: str) -> Dict:
        """等待交易确认"""
        while True:
            try:
                receipt = self.w3.eth.get_transaction_receipt(tx_hash)
                if receipt:
                    return receipt
            except Exception:
                pass
            await asyncio.sleep(1)

    def get_network_status(self) -> Dict[str, Any]:
        """获取网络状态"""
        try:
            return {
                "network": self.network["name"],
                "connected": self.w3.is_connected() if self.w3 else False,
                "block_number": self.w3.eth.block_number if self.w3 else 0,
                "gas_price": self.w3.from_wei(self.w3.eth.gas_price, 'gwei') if self.w3 else 0,
                "account": self.account.address if self.account else None
            }
        except Exception as e:
            # 确保即使在出错时也返回包含所有必要键的字典
            return {
                "network": self.network["name"],  # 使用配置中的网络名称
                "connected": False,
                "block_number": 0,
                "gas_price": 0,
                "account": None,
                "error": str(e)
            }

================
File: tokens.py
================
from typing import Dict, List, Any
import time
from blockchain import blockchain

class TokenSystem:
    def __init__(self):
        self.balances = {}
        self.transactions = []
        self.total_supply = 1000000
        self.carbon_price = 8
        self.carbon_records = []
    
    def init_balance(self, node_id: str, amount: float = 0) -> None:
        if node_id not in self.balances:
            self.balances[node_id] = amount
            blockchain.add_transaction({"type": "init_balance", "node_id": node_id, "amount": amount})
    
    def get_balance(self, node_id: str) -> float:
        return self.balances.get(node_id, 0)
    
    def transfer(self, from_node: str, to_node: str, amount: float, tx_type: str = "transfer") -> bool:
        if from_node not in self.balances or to_node not in self.balances:
            return False
        if self.balances[from_node] < amount:
            return False
        self.balances[from_node] -= amount
        self.balances[to_node] += amount
        tx = {"from": from_node, "to": to_node, "amount": amount, "type": tx_type, "timestamp": time.time()}
        self.transactions.append(tx)
        blockchain.add_transaction({"type": "token_transfer", "data": tx})
        blockchain.mine_pending_transactions("SuperNode_A")
        return True
    
    def reward_super_node(self, node_id: str, block_count: int) -> None:
        reward = block_count * 10
        self.balances[node_id] = self.balances.get(node_id, 0) + reward
        tx = {"from": "system", "to": node_id, "amount": reward, "type": "super_node_reward", "timestamp": time.time()}
        self.transactions.append(tx)
        blockchain.add_transaction({"type": "token_reward", "data": tx})
        blockchain.mine_pending_transactions("SuperNode_A")
    
    def compensate_carbon(self, carrier_id: str, carbon_amount: float) -> None:
        compensation = carbon_amount * self.carbon_price
        self.balances[carrier_id] = self.balances.get(carrier_id, 0) + compensation
        record = {"carrier_id": carrier_id, "carbon_amount": carbon_amount, "compensation": compensation, "timestamp": time.time()}
        self.carbon_records.append(record)
        tx = {"from": "system", "to": carrier_id, "amount": compensation, "type": "carbon_compensation", "timestamp": time.time()}
        self.transactions.append(tx)
        blockchain.add_transaction({"type": "carbon_compensation", "data": tx})
        blockchain.mine_pending_transactions("SuperNode_A")
    
    def get_flow_data(self) -> List[Dict[str, Any]]:
        return self.transactions[-10:]
    
    def get_total_supply(self) -> float:
        return self.total_supply
    
    def get_circulation(self) -> float:
        return sum(self.balances.values())
    
    def update_carbon_price(self, new_price: float) -> None:
        self.carbon_price = new_price
    
    def burn_tokens(self, amount: float) -> None:
        self.total_supply -= amount
        blockchain.add_transaction({"type": "burn_tokens", "amount": amount})
    
    def get_stats(self) -> Dict[str, Any]:
        avg_balance = sum(self.balances.values()) / len(self.balances) if self.balances else 0
        carbon_offset = sum(record["carbon_amount"] for record in self.carbon_records)
        return {
            "total_supply": self.total_supply,
            "circulation": self.get_circulation(),
            "carbon_price": self.carbon_price,
            "active_users": len(self.balances),
            "total_transactions": len(self.transactions),
            "average_balance": avg_balance,
            "latest_transaction": self.transactions[-1] if self.transactions else None,
            "system_reserve": self.total_supply - self.get_circulation(),
            "carbon_offset": carbon_offset
        }
    
    def get_carbon_data(self) -> List[Dict[str, Any]]:
        return self.carbon_records or [
            {"transport_type": "sea", "emissions": 100, "compensation": 800, "timestamp": time.time()},
            {"transport_type": "air", "emissions": 500, "compensation": 4000, "timestamp": time.time()}
        ]

token_system = TokenSystem()

================
File: visuals.py
================
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
from typing import List, Dict, Any
import streamlit as st
import networkx as nx
from datetime import datetime, timedelta

class LogisticsVisualizer:
    def __init__(self):
        # 更新样式设置，使用新版本的命名方式
        sns.set_theme()  # 使用 seaborn 默认主题
        sns.set_palette("husl")
        
    def plot_solutions(self, solutions: List[Dict[str, Any]]) -> plt.Figure:
        plt.clf()  # 清理全局状态
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
        
        # 提取数据
        prices = [s['price'] for s in solutions]
        emissions = [s['carbon_footprint'] for s in solutions]
        days = [s['estimated_days'] for s in solutions]
        types = [s['type'] for s in solutions]
        
        # 左图：价格vs碳排放散点图
        scatter = ax1.scatter(prices, emissions, c=days, 
                            cmap='YlOrRd', s=100, alpha=0.6)
        ax1.set_xlabel('Price (USD)')
        ax1.set_ylabel('Carbon Emissions (kg CO2)')
        ax1.set_title('Price vs Carbon Emissions')
        
        # 添加方案标签
        for i, type_name in enumerate(types):
            ax1.annotate(type_name, (prices[i], emissions[i]), 
                        xytext=(5, 5), textcoords='offset points')
        
        # 添加颜色条（表示时效）
        plt.colorbar(scatter, ax=ax1, label='Estimated Days')
        
        # 右图：方案对比条形图
        x = range(len(solutions))
        width = 0.35
        
        # 归一化数据用于对比
        norm_prices = [p/max(prices) for p in prices]
        norm_emissions = [e/max(emissions) for e in emissions]
        norm_days = [d/max(days) for d in days]
        
        ax2.bar([i-width for i in x], norm_prices, width, label='Price', color='skyblue')
        ax2.bar(x, norm_emissions, width, label='Emissions', color='lightgreen')
        ax2.bar([i+width for i in x], norm_days, width, label='Time', color='salmon')
        
        ax2.set_ylabel('Normalized Value')
        ax2.set_title('Solution Comparison')
        ax2.set_xticks(x)
        ax2.set_xticklabels(types)
        ax2.legend()
        
        plt.tight_layout()
        return fig

    def plot_token_flow(self, flow_data: List[Dict[str, Any]]) -> plt.Figure:
        plt.clf()  # 清理全局状态
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 10))
        
        # 上图：代币流动网络图
        G = nx.DiGraph()
        
        # 添加节点和边
        for tx in flow_data:
            G.add_edge(tx['from'], tx['to'], 
                      weight=tx['amount'],
                      type=tx['type'])
        
        # 设置节点位置
        pos = nx.spring_layout(G)
        
        # 绘制节点
        nx.draw_networkx_nodes(G, pos, node_color='lightblue', 
                             node_size=500, alpha=0.6, ax=ax1)
        
        # 绘制边（使用不同颜色表示不同类型的交易）
        edge_colors = {'transfer': 'gray', 
                      'reward': 'green',
                      'carbon_compensation': 'blue'}
                      
        for edge_type in edge_colors:
            edges = [(u, v) for (u, v, d) in G.edges(data=True) 
                    if d['type'] == edge_type]
            nx.draw_networkx_edges(G, pos, edgelist=edges, 
                                 edge_color=edge_colors[edge_type],
                                 alpha=0.6, ax=ax1)
        
        # 添加节点标签
        nx.draw_networkx_labels(G, pos, ax=ax1)
        ax1.set_title('Token Flow Network')
        
        # 下图：代币余额时间序列
        balances = {}
        timestamps = []
        
        # 计算累计余额
        for tx in sorted(flow_data, key=lambda x: x['timestamp']):
            timestamp = datetime.fromtimestamp(tx['timestamp'])
            timestamps.append(timestamp)
            
            # 更新发送方余额
            if tx['from'] not in balances:
                balances[tx['from']] = 0
            balances[tx['from']] -= tx['amount']
            
            # 更新接收方余额
            if tx['to'] not in balances:
                balances[tx['to']] = 0
            balances[tx['to']] += tx['amount']
        
        # 绘制余额变化
        for node, balance in balances.items():
            ax2.plot(timestamps, [balance]*len(timestamps), 
                    label=node, marker='o')
        
        ax2.set_xlabel('Time')
        ax2.set_ylabel('Token Balance')
        ax2.set_title('Token Balance Changes')
        ax2.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
        ax2.grid(True)
        
        plt.tight_layout()
        return fig

    def plot_logistics_status(self, status: Dict[str, Any]) -> plt.Figure:
        """
        绘制物流状态图
        
        Args:
            status: 物流状态字典，包含 current_stage 字段（整数，表示当前阶段的索引）
            
        Returns:
            matplotlib图表对象
        """
        plt.clf()  # 清理全局状态
        stages = ["warehouse", "customs", "transport", "delivery"]
        
        # 直接使用传入的 current_stage 作为索引
        current_stage_index = status["current_stage"]
        
        # 确保 current_stage_index 是有效的整数
        if not isinstance(current_stage_index, int):
            print(f"Error: current_stage_index should be an integer, got {type(current_stage_index)}: {current_stage_index}")
            current_stage_index = 0
        else:
            # 确保索引在有效范围内
            current_stage_index = max(0, min(current_stage_index, len(stages) - 1))
        
        print(f"Debug: plot_logistics_status - current_stage_index: {current_stage_index}")
        
        fig, ax = plt.subplots(figsize=(8, 1))
        for i, stage in enumerate(stages):
            color = 'green' if i <= current_stage_index else 'grey'  # 使用 <= 以包含当前阶段
            ax.barh(0, 1, left=i, color=color, edgecolor='black')
            ax.text(i + 0.5, 0, stage, ha='center', va='center')
        
        ax.set_xlim(0, len(stages))
        ax.set_yticks([])
        ax.set_xticks(range(len(stages)))
        ax.set_xticklabels(stages)
        ax.set_title("Logistics Status")
        
        plt.tight_layout()
        return fig

    def plot_carbon_analysis(self, carbon_data: List[Dict[str, Any]]) -> plt.Figure:
        plt.clf()  # 清理全局状态
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
        
        # 转换为DataFrame
        df = pd.DataFrame(carbon_data)
        
        # 左图：运输方式碳排放对比
        sns.boxplot(data=df, x='transport_type', y='emissions', ax=ax1)
        ax1.set_title('Carbon Emissions by Transport Type')
        ax1.set_xlabel('Transport Type')
        ax1.set_ylabel('CO2 Emissions (kg)')
        
        # 右图：碳补偿分布
        sns.histplot(data=df, x='compensation', bins=20, ax=ax2)
        ax2.set_title('Carbon Compensation Distribution')
        ax2.set_xlabel('Compensation Amount (Tokens)')
        ax2.set_ylabel('Frequency')
        
        plt.tight_layout()
        return fig



================================================================
End of Codebase
================================================================
